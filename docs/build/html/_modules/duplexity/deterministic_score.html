<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>duplexity.deterministic_score &mdash; Duplexity 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Duplexity
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metrics/metrics.html">Metrics</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Duplexity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">duplexity.deterministic_score</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for duplexity.deterministic_score</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Deterministic Score</span>
<span class="sd">===================</span>

<span class="sd">Forecast evaluation and skill scores for deterministic continuous forecasts.</span>


<span class="sd">Continuous Metrics</span>
<span class="sd">------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: ../generated/</span>

<span class="sd">    mean_absolute_error</span>
<span class="sd">    mean_squared_error</span>
<span class="sd">    root_mean_squared_error</span>
<span class="sd">    bias</span>
<span class="sd">    debiased_root_mean_squared_error</span>
<span class="sd">    pearson_correlation</span>

<span class="sd">Categorical Metrics</span>
<span class="sd">-------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: ../generated/</span>

<span class="sd">    confusion_matrix</span>
<span class="sd">    precision</span>
<span class="sd">    recall</span>
<span class="sd">    f1_score</span>
<span class="sd">    accuracy</span>
<span class="sd">    critical_success_index</span>
<span class="sd">    equitable_threat_score</span>
<span class="sd">    false_alarm_ratio</span>
<span class="sd">    probability_of_detection</span>
<span class="sd">    gilbert_skill_score</span>
<span class="sd">    heidke_skill_score</span>
<span class="sd">    peirce_skill_score</span>
<span class="sd">    symmetric_extremal_dependence_index</span>

<span class="sd">&quot;&quot;&quot;</span>





<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">uniform_filter</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="kn">from</span> <span class="nn">duplexity.utils</span> <span class="kn">import</span> <span class="n">_to_numpy</span><span class="p">,</span> <span class="n">_check_shapes</span><span class="p">,</span> <span class="n">_check_2d_data</span><span class="p">,</span> <span class="n">_binary_classification</span>



<span class="c1">###########################################</span>
<span class="c1">##             Continuous Score          ##</span>
<span class="c1">###########################################</span>

<span class="n">all_continuous_metrics</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;MAE&quot;</span><span class="p">,</span>  <span class="c1"># Mean Absolute Error</span>
    <span class="s2">&quot;MSE&quot;</span><span class="p">,</span>  <span class="c1"># Mean Squared Error</span>
    <span class="s2">&quot;RMSE&quot;</span><span class="p">,</span> <span class="c1"># Root Mean Squared Error</span>
    <span class="s2">&quot;Bias&quot;</span><span class="p">,</span> <span class="c1"># Bias</span>
    <span class="s2">&quot;DRMSE&quot;</span><span class="p">,</span> <span class="c1"># Debiased Root Mean Squared Error</span>
    <span class="s2">&quot;Pearson Correlation&quot;</span> <span class="c1"># Pearson Correlation</span>
<span class="p">]</span>

<div class="viewcode-block" id="mean_absolute_error">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.mean_absolute_error">[docs]</a>
<span class="k">def</span> <span class="nf">mean_absolute_error</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                        <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Mean Absolute Error (MAE) between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Mean Absolute Error (MAE), which measures the average magnitude of the absolute errors </span>
<span class="sd">        between observed and predicted values. MAE provides a linear score that does not consider the direction of errors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The MAE is a widely used metric in regression analysis and is particularly useful for evaluating model performance </span>
<span class="sd">    where all errors are weighted equally.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the MAE for each pair of elements in the lists and then return the average of these individual MAEs.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; mean_absolute_error(observed_data, output_data)</span>
<span class="sd">    0.337  # Example output, depends on the random values</span>

<span class="sd">    In this example, `mean_absolute_error` calculates the MAE for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final MAE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">observed</span> <span class="o">-</span> <span class="n">output</span><span class="p">))</span></div>


<div class="viewcode-block" id="mean_squared_error">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.mean_squared_error">[docs]</a>
<span class="k">def</span> <span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                       <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Mean Squared Error (MSE) between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Mean Squared Error (MSE), which measures the average squared difference between observed and predicted values. </span>
<span class="sd">        MSE is a quadratic scoring rule that penalizes larger errors more than smaller ones.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The MSE is a common metric in regression analysis, used to measure the accuracy of a model. </span>
<span class="sd">    Unlike MAE, it gives more weight to larger errors due to the squaring of differences.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the MSE for each pair of elements in the lists and then return the average of these individual MSEs.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; mean_squared_error(observed_data, output_data)</span>
<span class="sd">    0.112  # Example output, depends on the random values</span>

<span class="sd">    In this example, `mean_squared_error` calculates the MSE for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final MSE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">output</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="root_mean_squared_error">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.root_mean_squared_error">[docs]</a>
<span class="k">def</span> <span class="nf">root_mean_squared_error</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                            <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Root Mean Squared Error (RMSE) between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Root Mean Squared Error (RMSE), which is the square root of the average squared differences </span>
<span class="sd">        between observed and predicted values. RMSE is sensitive to large errors and is often used to assess the accuracy of a model.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    RMSE is a commonly used metric in regression analysis that provides an overall measure of the error magnitude. </span>
<span class="sd">    It is particularly useful when comparing different models or algorithms, as it combines the advantages of both </span>
<span class="sd">    the mean absolute error (MAE) and the mean squared error (MSE).</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the RMSE for each pair of elements in the lists and then return the average of these individual RMSEs.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; root_mean_squared_error(observed_data, output_data)</span>
<span class="sd">    0.355  # Example output, depends on the random values</span>

<span class="sd">    In this example, `root_mean_squared_error` calculates the RMSE for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final RMSE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">output</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="bias">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.bias">[docs]</a>
<span class="k">def</span> <span class="nf">bias</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
         <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the bias between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The bias, which is the average difference between the observed and model output values. </span>
<span class="sd">        Positive bias indicates overestimation by the model, while negative bias indicates underestimation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Bias is a simple but important metric that indicates the overall tendency of a model to overestimate or </span>
<span class="sd">    underestimate the observed values. It is often used in conjunction with other metrics like RMSE or MAE </span>
<span class="sd">    to provide a fuller picture of model performance.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the bias for each pair of elements in the lists and then return the average of these individual biases.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; bias(observed_data, output_data)</span>
<span class="sd">    -0.027  # Example output, depends on the random values</span>

<span class="sd">    In this example, `bias` calculates the bias for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final bias.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">output</span> <span class="o">-</span> <span class="n">observed</span><span class="p">)</span></div>


<div class="viewcode-block" id="debiased_root_mean_squared_error">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.debiased_root_mean_squared_error">[docs]</a>
<span class="k">def</span> <span class="nf">debiased_root_mean_squared_error</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                                     <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Debiased Root Mean Squared Error (DRMSE) between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Debiased Root Mean Squared Error (DRMSE), which is the square root of the mean squared error </span>
<span class="sd">        calculated after removing the bias between observed and predicted values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Debiased Root Mean Squared Error (DRMSE) adjusts for any systematic bias in the predictions </span>
<span class="sd">    by first removing the bias from the predictions and then calculating the root mean squared error. </span>
<span class="sd">    This metric provides a clearer indication of the model&#39;s performance by focusing on the variability </span>
<span class="sd">    in the errors after accounting for bias.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the DRMSE for each pair of elements in the lists and then return the average of these individual DRMSEs.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; debiased_root_mean_squared_error(observed_data, output_data)</span>
<span class="sd">    0.278  # Example output, depends on the random values</span>

<span class="sd">    In this example, `debiased_root_mean_squared_error` calculates the DRMSE for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final DRMSE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="n">bias_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">output</span> <span class="o">-</span> <span class="n">observed</span><span class="p">)</span>
    <span class="n">debiased_predictions</span> <span class="o">=</span> <span class="n">output</span> <span class="o">-</span> <span class="n">bias_value</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">observed</span> <span class="o">-</span> <span class="n">debiased_predictions</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="pearson_correlation">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.pearson_correlation">[docs]</a>
<span class="k">def</span> <span class="nf">pearson_correlation</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                        <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Pearson correlation coefficient between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Pearson correlation coefficient, a measure of the linear relationship between the observed and model output values. </span>
<span class="sd">        The coefficient ranges from -1 to 1, where 1 indicates a perfect positive linear relationship, -1 indicates a perfect negative </span>
<span class="sd">        linear relationship, and 0 indicates no linear relationship.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Pearson correlation coefficient is a widely used statistical measure to assess the strength and direction </span>
<span class="sd">    of the linear relationship between two variables. A high absolute value of the coefficient indicates a strong linear relationship.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the Pearson correlation for each pair of elements in the lists and then return the average of these individual coefficients.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; pearson_correlation(observed_data, output_data)</span>
<span class="sd">    0.756  # Example output, depends on the random values</span>

<span class="sd">    In this example, `pearson_correlation` calculates the Pearson correlation coefficient for each pair of `xr.DataArray` objects in `observed_data` </span>
<span class="sd">    and `output_data` and then averages these values to produce the final coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">observed</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">output</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="calculate_continuous_metrics">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.calculate_continuous_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_continuous_metrics</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                                 <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                                 <span class="n">metrics</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate specified continuous metrics between observed and model output values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    metrics : Union[str, Tuple[str], List[str]], optional</span>
<span class="sd">        A string, tuple, or list of strings specifying the metrics to calculate. </span>
<span class="sd">        If not provided, all available metrics will be calculated. Available metrics are:</span>
<span class="sd">        - &quot;MAE&quot; (Mean Absolute Error)</span>
<span class="sd">        - &quot;MSE&quot; (Mean Squared Error)</span>
<span class="sd">        - &quot;RMSE&quot; (Root Mean Squared Error)</span>
<span class="sd">        - &quot;Bias&quot;</span>
<span class="sd">        - &quot;DRMSE&quot; (Debiased Root Mean Squared Error)</span>
<span class="sd">        - &quot;Pearson Correlation&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary where the keys are the names of the metrics and the values are the corresponding calculated values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function allows for flexible calculation of multiple continuous metrics between observed and model output data.</span>
<span class="sd">    Users can specify one or more metrics, or calculate all available metrics by leaving the `metrics` parameter as `None`.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the specified metrics for each pair of elements in the lists and then return the average of these individual metrics.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; output_data = [xr.DataArray(np.random.rand(3, 3)), xr.DataArray(np.random.rand(3, 3))]</span>
<span class="sd">    &gt;&gt;&gt; calculate_continuous_metrics(observed_data, output_data, metrics=[&quot;MAE&quot;, &quot;RMSE&quot;, &quot;Bias&quot;])</span>
<span class="sd">    {&#39;MAE&#39;: 0.243, &#39;RMSE&#39;: 0.371, &#39;Bias&#39;: -0.015}  # Example output, depends on the random values</span>

<span class="sd">    In this example, `calculate_continuous_metrics` calculates the Mean Absolute Error, Root Mean Squared Error, </span>
<span class="sd">    and Bias for each pair of `xr.DataArray` objects in `observed_data` and `output_data`, and returns the results as a dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">available_metrics</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;MAE&quot;</span><span class="p">:</span> <span class="n">mean_absolute_error</span><span class="p">,</span>
        <span class="s2">&quot;MSE&quot;</span><span class="p">:</span> <span class="n">mean_squared_error</span><span class="p">,</span>
        <span class="s2">&quot;RMSE&quot;</span><span class="p">:</span> <span class="n">root_mean_squared_error</span><span class="p">,</span>
        <span class="s2">&quot;Bias&quot;</span><span class="p">:</span> <span class="n">bias</span><span class="p">,</span>
        <span class="s2">&quot;DRMSE&quot;</span><span class="p">:</span> <span class="n">debiased_root_mean_squared_error</span><span class="p">,</span>
        <span class="s2">&quot;Pearson Correlation&quot;</span><span class="p">:</span> <span class="n">pearson_correlation</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">available_metrics</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">metrics</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">available_metrics</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">available_metrics</span><span class="p">[</span><span class="n">metric</span><span class="p">](</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metric &#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&#39; is not recognized. Available metrics are: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">available_metrics</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span></div>


<span class="c1">###########################################</span>
<span class="c1">##             Categorical Score         ##        </span>
<span class="c1">###########################################</span>

<span class="n">all_categorical_metrics</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Confusion Matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Precision&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Recall&quot;</span><span class="p">,</span>
    <span class="s2">&quot;F1 Score&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Accuracy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CSI&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ETS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FAR&quot;</span><span class="p">,</span>
    <span class="s2">&quot;POD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GSS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;HSS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PSS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SEDI&quot;</span>
<span class="p">]</span>

<div class="viewcode-block" id="confusion_matrix">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.confusion_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                     <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                     <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the confusion matrix between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        A confusion matrix in the form of a 2x2 NumPy array, where:</span>
<span class="sd">        - The first row corresponds to the actual negative cases (True Negative, False Positive).</span>
<span class="sd">        - The second row corresponds to the actual positive cases (False Negative, True Positive).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The confusion matrix is a widely used tool for evaluating the performance of a classification model. </span>
<span class="sd">    It provides insights into the types of errors the model makes and can be used to derive other metrics like precision, recall, and F1-score.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the confusion matrix for each pair of elements in the lists and then return the average confusion matrix.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.array([0, 1, 0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.array([0.2, 0.8, 0.1, 0.6, 0.4, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; confusion_matrix(observed_data, output_data, threshold=0.5)</span>
<span class="sd">    array([[2, 1],</span>
<span class="sd">           [0, 3]])</span>

<span class="sd">    In this example, the `confusion_matrix` function calculates the confusion matrix by comparing the observed values </span>
<span class="sd">    with the model output values, using a threshold of 0.5 to classify the output data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="n">observed_binary</span> <span class="o">=</span> <span class="n">_binary_classification</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">output_binary</span> <span class="o">=</span> <span class="n">_binary_classification</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    
    <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">output_binary</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">observed_binary</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">FN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">output_binary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">observed_binary</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">FP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">output_binary</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">observed_binary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">TN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">output_binary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">observed_binary</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">TP</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">FN</span><span class="o">.</span><span class="n">sum</span><span class="p">()],</span> <span class="p">[</span><span class="n">FP</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">TN</span><span class="o">.</span><span class="n">sum</span><span class="p">()]])</span></div>


<div class="viewcode-block" id="precision">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.precision">[docs]</a>
<span class="k">def</span> <span class="nf">precision</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
              <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
              <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the precision between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The precision, which is the ratio of true positives to the sum of true positives and false positives.</span>
<span class="sd">        Precision = TP / (TP + FP)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Precision is a key metric in binary classification that measures the accuracy of the positive predictions made by the model. </span>
<span class="sd">    It is particularly useful in situations where the cost of false positives is high.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the precision for each pair of elements in the lists and then return the average precision.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.array([0, 1, 0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.array([0.2, 0.8, 0.1, 0.6, 0.4, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; precision(observed_data, output_data, threshold=0.5)</span>
<span class="sd">    1.0</span>

<span class="sd">    In this example, the `precision` function calculates the precision by comparing the observed values </span>
<span class="sd">    with the model output values, using a threshold of 0.5 to classify the output data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="recall">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.recall">[docs]</a>
<span class="k">def</span> <span class="nf">recall</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
           <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
           <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the recall between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The recall, which is the ratio of true positives to the sum of true positives and false negatives.</span>
<span class="sd">        Recall = TP / (TP + FN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Recall, also known as sensitivity or true positive rate, is a key metric in binary classification that measures </span>
<span class="sd">    the model&#39;s ability to correctly identify all positive instances. It is particularly important in scenarios where </span>
<span class="sd">    minimizing false negatives is crucial.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the recall for each pair of elements in the lists and then return the average recall.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.array([0, 1, 0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.array([0.2, 0.8, 0.1, 0.6, 0.4, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; recall(observed_data, output_data, threshold=0.5)</span>
<span class="sd">    1.0</span>

<span class="sd">    In this example, the `recall` function calculates the recall by comparing the observed values </span>
<span class="sd">    with the model output values, using a threshold of 0.5 to classify the output data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="f1_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.f1_score">[docs]</a>
<span class="k">def</span> <span class="nf">f1_score</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
             <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
             <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the F1 score between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The F1 score, which is the harmonic mean of precision and recall.</span>
<span class="sd">        F1 Score = 2 * (Precision * Recall) / (Precision + Recall)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The F1 score is a widely used metric in binary classification that balances precision and recall, making it </span>
<span class="sd">    particularly useful in scenarios where the distribution of classes is imbalanced or where both false positives </span>
<span class="sd">    and false negatives need to be considered.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the F1 score for each pair of elements in the lists and then return the average F1 score.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.array([0, 1, 0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.array([0.2, 0.8, 0.1, 0.6, 0.4, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; f1_score(observed_data, output_data, threshold=0.5)</span>
<span class="sd">    1.0</span>

<span class="sd">    In this example, the `f1_score` function calculates the F1 score by first computing the precision and recall using the </span>
<span class="sd">    specified threshold, and then calculating the harmonic mean of these two metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">precision_value</span> <span class="o">=</span> <span class="n">precision</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">recall_value</span> <span class="o">=</span> <span class="n">recall</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">precision_value</span> <span class="o">*</span> <span class="n">recall_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision_value</span> <span class="o">+</span> <span class="n">recall_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="accuracy">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.accuracy">[docs]</a>
<span class="k">def</span> <span class="nf">accuracy</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
             <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
             <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the accuracy between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The accuracy, which is the ratio of the number of correct predictions to the total number of predictions.</span>
<span class="sd">        Accuracy = (TP + TN) / (TP + TN + FP + FN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Accuracy is a widely used metric in binary classification that measures the overall correctness of the model&#39;s predictions.</span>
<span class="sd">    It is most useful when the classes are balanced; however, it can be misleading when dealing with imbalanced datasets.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the accuracy for each pair of elements in the lists and then return the average accuracy.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">cm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="critical_success_index">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.critical_success_index">[docs]</a>
<span class="k">def</span> <span class="nf">critical_success_index</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                           <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                           <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Critical Success Index (CSI) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Critical Success Index (CSI), which is the ratio of true positives to the sum of true positives, false negatives, and false positives.</span>
<span class="sd">        CSI = TP / (TP + FN + FP)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Critical Success Index (CSI), also known as the Threat Score, is a metric used in binary classification to measure </span>
<span class="sd">    the accuracy of positive predictions. Unlike accuracy, CSI accounts for both false positives and false negatives, </span>
<span class="sd">    making it particularly useful in assessing model performance in imbalanced datasets or for rare events.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the CSI for each pair of elements in the lists and then return the average CSI.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="equitable_threat_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.equitable_threat_score">[docs]</a>
<span class="k">def</span> <span class="nf">equitable_threat_score</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                           <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                           <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Equitable Threat Score (ETS) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Equitable Threat Score (ETS), which adjusts the Critical Success Index (CSI) by accounting for hits due to random chance.</span>
<span class="sd">        ETS = (TP - CH) / (TP + FN + FP - CH)</span>
<span class="sd">        where CH (Chance Hits) = (TP + FN) * (TP + FP) / (TP + FN + FP + TN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Equitable Threat Score (ETS) is a metric used in binary classification to measure the skill of a model in predicting positive events, </span>
<span class="sd">    adjusted for the number of hits that could occur by random chance. ETS is particularly useful in scenarios involving rare events or imbalanced datasets, </span>
<span class="sd">    as it provides a more accurate assessment of model performance than the Critical Success Index (CSI) alone.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the ETS for each pair of elements in the lists and then return the average ETS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">hits_random</span> <span class="o">=</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">cm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hits_random</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hits_random</span><span class="p">)</span></div>


<div class="viewcode-block" id="false_alarm_ratio">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.false_alarm_ratio">[docs]</a>
<span class="k">def</span> <span class="nf">false_alarm_ratio</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                      <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                      <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the False Alarm Ratio (FAR) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The False Alarm Ratio (FAR), which is the ratio of false positives to the sum of false positives and true positives.</span>
<span class="sd">        FAR = FP / (FP + TP)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The False Alarm Ratio (FAR) is a metric used in binary classification to measure the proportion of positive predictions that are incorrect. </span>
<span class="sd">    It is particularly important in scenarios where false positives are costly or problematic. FAR ranges from 0 to 1, with 0 indicating no false alarms </span>
<span class="sd">    and 1 indicating that all positive predictions are false.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the FAR for each pair of elements in the lists and then return the average FAR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>



<div class="viewcode-block" id="probability_of_detection">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.probability_of_detection">[docs]</a>
<span class="k">def</span> <span class="nf">probability_of_detection</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                             <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                             <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Probability of Detection (POD) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Probability of Detection (POD), which is the ratio of true positives to the sum of true positives and false negatives.</span>
<span class="sd">        POD = TP / (TP + FN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Probability of Detection (POD), also known as sensitivity or the true positive rate, is a key metric in binary classification </span>
<span class="sd">    that measures the ability of the model to correctly identify positive cases. A POD of 1 indicates perfect detection of all positive cases, </span>
<span class="sd">    while a POD of 0 indicates that no positive cases were detected.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the POD for each pair of elements in the lists and then return the average POD.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="gilbert_skill_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.gilbert_skill_score">[docs]</a>
<span class="k">def</span> <span class="nf">gilbert_skill_score</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                        <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                        <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Gilbert Skill Score (GSS) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Gilbert Skill Score (GSS), also known as the Equitable Threat Score (ETS), which adjusts the Critical Success Index (CSI) </span>
<span class="sd">        by accounting for hits that could occur due to random chance.</span>
<span class="sd">        GSS = (TP - CH) / (TP + FN + FP - CH)</span>
<span class="sd">        where CH (Chance Hits) = (TP + FN) * (TP + FP) / (TP + FN + FP + TN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Gilbert Skill Score (GSS) is a metric used in binary classification to assess the skill of a model by considering </span>
<span class="sd">    both correct predictions and the impact of random chance. It is particularly useful in cases involving rare events </span>
<span class="sd">    or imbalanced datasets, where traditional metrics like accuracy may be misleading.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the GSS for each pair of elements in the lists and then return the average GSS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">hits_random</span> <span class="o">=</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">cm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hits_random</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hits_random</span><span class="p">)</span></div>


<div class="viewcode-block" id="heidke_skill_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.heidke_skill_score">[docs]</a>
<span class="k">def</span> <span class="nf">heidke_skill_score</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                       <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                       <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Heidke Skill Score (HSS) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Heidke Skill Score (HSS), which measures the skill of a binary classification model compared to random chance.</span>
<span class="sd">        HSS = 2 * (TP * TN - FP * FN) / ((TP + FN) * (FN + TN) + (TP + FP) * (FP + TN))</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Heidke Skill Score (HSS) is a metric used to assess the accuracy of a model&#39;s predictions relative to random chance. </span>
<span class="sd">    Unlike some other metrics, HSS considers all elements of the confusion matrix (TP, TN, FP, FN) and is particularly useful </span>
<span class="sd">    when the goal is to compare model performance against a baseline of random prediction. HSS ranges from -1 to 1, </span>
<span class="sd">    where 1 indicates perfect skill, 0 indicates no skill, and negative values indicate worse-than-random performance.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the HSS for each pair of elements in the lists and then return the average HSS.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">false_alarms</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">misses</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">correct_negatives</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">hits</span> <span class="o">+</span> <span class="n">false_alarms</span> <span class="o">+</span> <span class="n">misses</span> <span class="o">+</span> <span class="n">correct_negatives</span>
    <span class="n">accuracy_random</span> <span class="o">=</span> <span class="p">((</span><span class="n">hits</span> <span class="o">+</span> <span class="n">false_alarms</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">hits</span> <span class="o">+</span> <span class="n">misses</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">correct_negatives</span> <span class="o">+</span> <span class="n">misses</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">correct_negatives</span> <span class="o">+</span> <span class="n">false_alarms</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">total</span> <span class="o">*</span> <span class="n">total</span><span class="p">)</span>
    <span class="n">accuracy_observed</span> <span class="o">=</span> <span class="p">(</span><span class="n">hits</span> <span class="o">+</span> <span class="n">correct_negatives</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">accuracy_observed</span> <span class="o">-</span> <span class="n">accuracy_random</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">accuracy_random</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">accuracy_random</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="peirce_skill_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.peirce_skill_score">[docs]</a>
<span class="k">def</span> <span class="nf">peirce_skill_score</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                       <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                       <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Peirce Skill Score (PSS) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Peirce Skill Score (PSS), also known as the True Skill Statistic (TSS), which is calculated as:</span>
<span class="sd">        PSS = TP / (TP + FN) - FP / (FP + TN)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Peirce Skill Score (PSS) is a metric used to measure the ability of a binary classifier to distinguish between positive and negative cases. </span>
<span class="sd">    PSS is particularly useful in evaluating model performance on imbalanced datasets, as it is unaffected by the proportion of positive and negative cases.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `np.array`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the PSS for each pair of elements in the lists and then return the average PSS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">POD</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">POFD</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">POD</span> <span class="o">-</span> <span class="n">POFD</span></div>


<div class="viewcode-block" id="sedi">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.sedi">[docs]</a>
<span class="k">def</span> <span class="nf">sedi</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
         <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
         <span class="n">threshold</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Symmetric Extremal Dependence Index (SEDI) between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">    </span>
<span class="sd">    threshold : float</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Symmetric Extremal Dependence Index (SEDI), calculated as:</span>
<span class="sd">        SEDI = (log(FP / (FP + TN)) - log(TP / (TP + FN))) / (log(FP / (FP + TN)) + log(TP / (TP + FN)))</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Symmetric Extremal Dependence Index (SEDI) is a metric used to evaluate the performance of a binary classifier, </span>
<span class="sd">    particularly in the context of rare events. It accounts for the balance between false positives and false negatives, </span>
<span class="sd">    providing a more nuanced assessment of model performance in extreme situations.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `xr.Dataset`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the SEDI for each pair of elements in the lists and then return the average SEDI.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">H</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">F</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>  <span class="c1"># Avoid division by zero and log(0)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">H</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">H</span><span class="p">))</span></div>


<div class="viewcode-block" id="calculate_categorical_metrics">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.calculate_categorical_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_categorical_metrics</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                                  <span class="n">output</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]],</span>
                                  <span class="n">metrics</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate specified categorical metrics between observed and model output values based on a specified threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing observed binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame, List[Union[xr.DataArray, np.array, pd.DataFrame]]]</span>
<span class="sd">        Array of shape (h, w) or (n, h, w) containing model output binary or continuous values, where n is the number of samples, h is the height, and w is the width.</span>

<span class="sd">    metrics : Union[str, Tuple[str], List[str]], optional</span>
<span class="sd">        A string, tuple, or list of strings specifying the categorical metrics to calculate. </span>
<span class="sd">        If not provided, all available metrics will be calculated. Available metrics are:</span>
<span class="sd">        - &quot;Confusion Matrix&quot;</span>
<span class="sd">        - &quot;Precision&quot;</span>
<span class="sd">        - &quot;Recall&quot;</span>
<span class="sd">        - &quot;F1 Score&quot;</span>
<span class="sd">        - &quot;Accuracy&quot;</span>
<span class="sd">        - &quot;CSI&quot; (Critical Success Index)</span>
<span class="sd">        - &quot;ETS&quot; (Equitable Threat Score)</span>
<span class="sd">        - &quot;FAR&quot; (False Alarm Ratio)</span>
<span class="sd">        - &quot;POD&quot; (Probability of Detection)</span>
<span class="sd">        - &quot;GSS&quot; (Gilbert Skill Score)</span>
<span class="sd">        - &quot;HSS&quot; (Heidke Skill Score)</span>
<span class="sd">        - &quot;PSS&quot; (Peirce Skill Score)</span>
<span class="sd">        - &quot;SEDI&quot; (Symmetric Extremal Dependence Index)</span>

<span class="sd">    threshold : float, optional</span>
<span class="sd">        A threshold value used to convert continuous output values into binary classifications (0 or 1). </span>
<span class="sd">        Default is 0.5. Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary where the keys are the names of the metrics and the values are the corresponding calculated values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function allows for flexible calculation of multiple categorical metrics between observed and model output data. </span>
<span class="sd">    Users can specify one or more metrics, or calculate all available metrics by leaving the `metrics` parameter as `None`.</span>

<span class="sd">    If the inputs `observed` and `output` are provided as lists of `xr.DataArray`, `xr.Dataset`, or `pd.DataFrame`, </span>
<span class="sd">    the function will calculate the specified metrics for each pair of elements in the lists and then return the average of these individual metrics.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.array([0, 1, 0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.array([0.2, 0.8, 0.1, 0.6, 0.4, 0.9])</span>
<span class="sd">    &gt;&gt;&gt; calculate_categorical_metrics(observed_data, output_data, metrics=[&quot;Precision&quot;, &quot;Recall&quot;, &quot;F1 Score&quot;], threshold=0.5)</span>
<span class="sd">    {&#39;Precision&#39;: 1.0, &#39;Recall&#39;: 1.0, &#39;F1 Score&#39;: 1.0}</span>

<span class="sd">    In this example, `calculate_categorical_metrics` calculates the Precision, Recall, and F1 Score </span>
<span class="sd">    by comparing the observed values with the model output values, using a threshold of 0.5 to classify the output data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">available_metrics</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Confusion Matrix&quot;</span><span class="p">:</span> <span class="n">confusion_matrix</span><span class="p">,</span>
        <span class="s2">&quot;Precision&quot;</span><span class="p">:</span> <span class="n">precision</span><span class="p">,</span>
        <span class="s2">&quot;Recall&quot;</span><span class="p">:</span> <span class="n">recall</span><span class="p">,</span>
        <span class="s2">&quot;F1 Score&quot;</span><span class="p">:</span> <span class="n">f1_score</span><span class="p">,</span>
        <span class="s2">&quot;Accuracy&quot;</span><span class="p">:</span> <span class="n">accuracy</span><span class="p">,</span>
        <span class="s2">&quot;CSI&quot;</span><span class="p">:</span> <span class="n">critical_success_index</span><span class="p">,</span>
        <span class="s2">&quot;ETS&quot;</span><span class="p">:</span> <span class="n">equitable_threat_score</span><span class="p">,</span>
        <span class="s2">&quot;FAR&quot;</span><span class="p">:</span> <span class="n">false_alarm_ratio</span><span class="p">,</span>
        <span class="s2">&quot;POD&quot;</span><span class="p">:</span> <span class="n">probability_of_detection</span><span class="p">,</span>
        <span class="s2">&quot;GSS&quot;</span><span class="p">:</span> <span class="n">gilbert_skill_score</span><span class="p">,</span>
        <span class="s2">&quot;HSS&quot;</span><span class="p">:</span> <span class="n">heidke_skill_score</span><span class="p">,</span>
        <span class="s2">&quot;PSS&quot;</span><span class="p">:</span> <span class="n">peirce_skill_score</span><span class="p">,</span>
        <span class="s2">&quot;SEDI&quot;</span><span class="p">:</span> <span class="n">sedi</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">available_metrics</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">metrics</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">available_metrics</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">available_metrics</span><span class="p">[</span><span class="n">metric</span><span class="p">](</span><span class="n">observed</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metric &#39;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&#39; is not recognized. Available metrics are: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">available_metrics</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span></div>






<span class="c1">################################</span>
<span class="c1">##           FSS              ##</span>
<span class="c1">################################</span>

<div class="viewcode-block" id="fss_initialize">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.fss_initialize">[docs]</a>
<span class="k">def</span> <span class="nf">fss_initialize</span><span class="p">(</span><span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize a fractions skill score (FSS) object.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        threshold (float): The intensity threshold value for binarizing the data.</span>
<span class="sd">        scale (int): Size of the neighborhood for calculating fractions, in pixels.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: FSS verification object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fss</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">sum_output_sq</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sum_output_observed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sum_observed_sq</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fss</span></div>




<div class="viewcode-block" id="fss_update">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.fss_update">[docs]</a>
<span class="k">def</span> <span class="nf">fss_update</span><span class="p">(</span><span class="n">fss</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">observed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update the FSS object with new forecast and observed data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    fss (dict): </span>
<span class="sd">        FSS verification object.</span>
<span class="sd">    output (np.array): </span>
<span class="sd">        Model output data array in shape (height, width).</span>
<span class="sd">    observed (np.array): </span>
<span class="sd">        Observed data array in shape (height, width).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">observed</span><span class="p">)</span>
    <span class="n">_check_2d_data</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">_check_2d_data</span> <span class="p">(</span><span class="n">observed</span><span class="p">)</span>


    <span class="n">threshold</span> <span class="o">=</span> <span class="n">fss</span><span class="p">[</span><span class="s1">&#39;threshold&#39;</span><span class="p">]</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">fss</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>

    <span class="n">binary_output</span> <span class="o">=</span> <span class="p">(</span><span class="n">_binary_classification</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">binary_observed</span> <span class="o">=</span><span class="p">(</span><span class="n">_binary_classification</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">smoothed_forecast</span> <span class="o">=</span> <span class="n">uniform_filter</span><span class="p">(</span><span class="n">binary_output</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">smoothed_observation</span> <span class="o">=</span> <span class="n">uniform_filter</span><span class="p">(</span><span class="n">binary_observed</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">smoothed_forecast</span> <span class="o">=</span> <span class="n">binary_output</span>
        <span class="n">smoothed_observation</span> <span class="o">=</span> <span class="n">binary_observed</span>

    <span class="n">fss</span><span class="p">[</span><span class="s2">&quot;sum_output_sq&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">smoothed_forecast</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">fss</span><span class="p">[</span><span class="s2">&quot;sum_output_observed&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">smoothed_forecast</span> <span class="o">*</span> <span class="n">smoothed_observation</span><span class="p">)</span>
    <span class="n">fss</span><span class="p">[</span><span class="s2">&quot;sum_observed_sq&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">smoothed_observation</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>




<div class="viewcode-block" id="fss_compute">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.fss_compute">[docs]</a>
<span class="k">def</span> <span class="nf">fss_compute</span><span class="p">(</span><span class="n">fss</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Fractions Skill Score (FSS).</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    fss (dict): FSS verification object.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    float: Fractions Skill Score.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sum_output_sq</span> <span class="o">=</span> <span class="n">fss</span><span class="p">[</span><span class="s1">&#39;sum_output_sq&#39;</span><span class="p">]</span>
    <span class="n">sum_observed_sq</span> <span class="o">=</span> <span class="n">fss</span><span class="p">[</span><span class="s1">&#39;sum_observed_sq&#39;</span><span class="p">]</span>
    <span class="n">sum_output_observed</span> <span class="o">=</span> <span class="n">fss</span><span class="p">[</span><span class="s1">&#39;sum_output_observed&#39;</span><span class="p">]</span>

    <span class="n">numerator</span> <span class="o">=</span> <span class="n">sum_output_sq</span> <span class="o">+</span> <span class="n">sum_observed_sq</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sum_output_observed</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">sum_output_sq</span> <span class="o">+</span> <span class="n">sum_observed_sq</span>

    <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">fss_value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="k">return</span> <span class="n">fss_value</span></div>



<div class="viewcode-block" id="calculate_fss_score">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.calculate_fss_score">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_fss_score</span><span class="p">(</span>
                   <span class="n">observed</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
                   <span class="n">output</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
                   <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="p">,</span> <span class="n">scale</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span>  <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Fractions Skill Score (FSS) between observed and model output values based on specified thresholds and scales.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    observed : Union[np.array, xr.DataArray, pd.DataFrame]</span>
<span class="sd">        Array of shape (h, w) containing observed binary or continuous values, where h is the height, and w is the width.</span>
<span class="sd">        </span>
<span class="sd">    output : Union[np.array, xr.DataArray, pd.DataFrame]</span>
<span class="sd">        Array of shape (h, w) containing model output binary or continuous values, where h is the height, and w is the width.</span>

<span class="sd">    threshold : Union[float, int, List[Union[float, int]]]</span>
<span class="sd">        A single threshold value or a list of threshold values used to convert continuous output values into binary classifications (0 or 1).</span>
<span class="sd">        Values greater than or equal to the threshold will be classified as 1, and values below the threshold will be classified as 0.</span>

<span class="sd">    scale : Union[float, int, List[Union[float, int]]]</span>
<span class="sd">        A single scale value or a list of scale values representing the neighborhood size for which the fractions are computed.</span>
<span class="sd">        The scale is typically expressed in grid points or distance units.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The Fractions Skill Score (FSS), which ranges from 0 to 1. An FSS of 1 indicates perfect agreement between the observed and forecast fractions, </span>
<span class="sd">        while an FSS of 0 indicates no skill.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Fractions Skill Score (FSS) is a metric used to assess the spatial accuracy of high-resolution forecasts, particularly in the context of precipitation. </span>
<span class="sd">    Unlike traditional categorical metrics, FSS considers the spatial distribution of the forecast and observed fields, making it well-suited for evaluating </span>
<span class="sd">    forecasts with spatial uncertainty.</span>

<span class="sd">    If a list of thresholds or scales is provided, the function will calculate the FSS for each combination of threshold and scale and then return the average FSS.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; observed_data = np.random.rand(100, 100)</span>
<span class="sd">    &gt;&gt;&gt; output_data = np.random.rand(100, 100)</span>
<span class="sd">    &gt;&gt;&gt; calculate_fss_score(observed_data, output_data, threshold=0.5, scale=10)</span>
<span class="sd">    0.85  # Example output, depends on the random values</span>

<span class="sd">    In this example, the `calculate_fss_score` function calculates the FSS by comparing the observed values </span>
<span class="sd">    with the model output values, using a threshold of 0.5 and a scale of 10 grid points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">_to_numpy</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">observed</span><span class="p">)</span>



    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span><span class="p">]</span>


    <span class="n">fss_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">scale_item</span> <span class="ow">in</span> <span class="n">scale</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">thre_item</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">fss</span> <span class="o">=</span> <span class="n">fss_initialize</span><span class="p">(</span><span class="n">thre_item</span><span class="p">,</span> <span class="n">scale_item</span><span class="p">)</span>
            <span class="n">fss_update</span><span class="p">(</span><span class="n">fss</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">observed</span><span class="p">)</span>
            <span class="n">fss_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fss_compute</span><span class="p">(</span><span class="n">fss</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fss_scores</span></div>




<span class="c1">#############################################################</span>
<span class="c1">##          Precipitation Smoothing Distance               ##</span>
<span class="c1">#############################################################</span>

<div class="viewcode-block" id="circular_kernel">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.circular_kernel">[docs]</a>
<span class="k">def</span> <span class="nf">circular_kernel</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a circular kernel with the given radius.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    radius (int): The radius of the circular kernel.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    np.array: A 2D array representing the circular kernel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the size of the kernel</span>
    <span class="n">r_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r_max</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># Calculate the center of the kernel</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">r_max</span>
    
    <span class="c1"># Get the row and column coordinates for the disk</span>
    <span class="n">row_coords</span><span class="p">,</span> <span class="n">col_coords</span> <span class="o">=</span> <span class="n">disk</span><span class="p">((</span><span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">),</span> <span class="n">radius</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Set the pixels inside the disk to 1</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">row_coords</span><span class="p">,</span> <span class="n">col_coords</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Normalize the kernel so that the sum of its elements equals 1</span>
    <span class="n">kernel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kernel</span></div>




<div class="viewcode-block" id="calculate_pss">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.calculate_pss">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_pss</span><span class="p">(</span><span class="n">output_smooth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">observed_smooth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Precipitation Smooth Score (PSS).</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    output_smooth (np.array): Smoothed forecast data.</span>
<span class="sd">    observed_smooth (np.array): Smoothed observed data.</span>
<span class="sd">    radius (float): Radius for smoothing.</span>
<span class="sd">    Q (float): Quality factor.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    float: Precipitation Symmetry Score (PSS).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">circular_kernel</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="n">output_smooth</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">output_smooth</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="n">observed_smooth</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">observed_smooth</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="n">PSS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">output_smooth</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">output_smooth</span> <span class="o">-</span> <span class="n">observed_smooth</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">PSS</span></div>


<div class="viewcode-block" id="calculate_psd">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.calculate_psd">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_psd</span><span class="p">(</span><span class="n">output</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">observed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">observed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_check_shapes</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">observed</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">observed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output and observed data are not two-dimensional.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">observed</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output and observed data are empty.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">output</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">observed</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output and observed data contain non-numeric values.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output and observed data are masked arrays which is not allowed.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">output</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">observed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output and observed data contain negative values which is not allowed.&quot;</span><span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">observed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="n">output_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">observed_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">output_avg</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">observed_avg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Return NaN for empty fields    </span>
    
    <span class="n">output_norm</span> <span class="o">=</span> <span class="n">output</span> <span class="o">/</span> <span class="n">output_avg</span>
    <span class="n">observed_norm</span> <span class="o">=</span> <span class="n">observed</span> <span class="o">/</span> <span class="n">observed_avg</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">output_norm</span><span class="p">,</span> <span class="n">observed_norm</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">output_diff</span> <span class="o">=</span> <span class="n">output_norm</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">output_norm</span><span class="p">,</span> <span class="n">observed_norm</span><span class="p">)</span>
    <span class="n">observed_diff</span> <span class="o">=</span> <span class="n">observed_norm</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">output_norm</span><span class="p">,</span> <span class="n">observed_norm</span><span class="p">)</span>
    
    <span class="n">Q</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">output_norm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="n">initial_radius</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PSS_initial</span> <span class="o">=</span> <span class="n">calculate_pss</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">observed_diff</span><span class="p">,</span> <span class="n">initial_radius</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">PSS_initial</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    
    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diagonal</span> <span class="o">*</span> <span class="mf">0.05</span><span class="p">)</span>
    
    <span class="n">radius2</span> <span class="o">=</span> <span class="n">initial_radius</span> <span class="o">+</span> <span class="n">dr</span>
    <span class="n">PSS2</span> <span class="o">=</span> <span class="n">calculate_pss</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">observed_diff</span><span class="p">,</span> <span class="n">radius2</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">PSS2</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">initial_radius</span> <span class="o">=</span> <span class="n">radius2</span>
        <span class="n">PSS_initial</span> <span class="o">=</span> <span class="n">PSS2</span>
        <span class="n">radius2</span> <span class="o">=</span> <span class="n">initial_radius</span> <span class="o">+</span> <span class="n">dr</span>
        <span class="n">PSS2</span> <span class="o">=</span> <span class="n">calculate_pss</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">observed_diff</span><span class="p">,</span> <span class="n">radius2</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">radius2</span> <span class="o">-</span> <span class="n">initial_radius</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">new_radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">initial_radius</span> <span class="o">+</span> <span class="n">radius2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">PSS_new</span> <span class="o">=</span> <span class="n">calculate_pss</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">observed_diff</span><span class="p">,</span> <span class="n">new_radius</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">PSS_new</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">radius2</span> <span class="o">=</span> <span class="n">new_radius</span>
            <span class="n">PSS2</span> <span class="o">=</span> <span class="n">PSS_new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_radius</span> <span class="o">=</span> <span class="n">new_radius</span>
            <span class="n">PSS_initial</span> <span class="o">=</span> <span class="n">PSS_new</span>
    
    <span class="n">PSD</span> <span class="o">=</span> <span class="mf">0.808</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">PSD</span></div>



<div class="viewcode-block" id="validate_with_psd">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.validate_with_psd">[docs]</a>
<span class="k">def</span> <span class="nf">validate_with_psd</span><span class="p">(</span><span class="n">observed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the forecasted data with the Precipitation Symmetry Distance (PSD).</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    observed (np.ndarray): Observed data array.</span>
<span class="sd">    forecasted (np.ndarray): Forecasted data array.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    np.ndarray: Array of PSD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">psd_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Calculating PSD&quot;</span><span class="p">):</span>
        <span class="n">observed_slice</span> <span class="o">=</span> <span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">output_slice</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">calculate_psd</span><span class="p">(</span><span class="n">observed_slice</span><span class="p">,</span> <span class="n">output_slice</span><span class="p">)</span>
        <span class="n">psd_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psd_results</span><span class="p">)</span></div>







<span class="c1">##################################################################################</span>
<span class="c1">##            Radially Averaged Power Spectral Density (RAPSD)                  ##</span>
<span class="c1">##################################################################################</span>


<div class="viewcode-block" id="compute_centred_coord_array">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.compute_centred_coord_array">[docs]</a>
<span class="k">def</span> <span class="nf">compute_centred_coord_array</span><span class="p">(</span><span class="n">H</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">W</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a 2D coordinate array, where the origin is at the center.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H : int</span>
<span class="sd">      The height of the array.</span>
<span class="sd">    W : int</span>
<span class="sd">      The width of the array.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">      The coordinate array.</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; compute_centred_coord_array(2, 2)</span>
<span class="sd">    (array([[-2],\n</span>
<span class="sd">        [-1],\n</span>
<span class="sd">        [ 0],\n</span>
<span class="sd">        [ 1],\n</span>
<span class="sd">        [ 2]]), array([[-2, -1,  0,  1,  2]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">H</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">H_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">W</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">W_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="n">y_coords</span><span class="p">,</span> <span class="n">x_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="n">H_slice</span><span class="p">,</span> <span class="n">W_slice</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">x_coords</span></div>



<div class="viewcode-block" id="rapsd">
<a class="viewcode-back" href="../../metrics/determinstic.html#duplexity.deterministic_score.rapsd">[docs]</a>
<span class="k">def</span> <span class="nf">rapsd</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">fft_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">fft_kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute radially averaged power spectral density (RAPSD) from the given</span>
<span class="sd">    2D input field.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field: array_like</span>
<span class="sd">        A 2d array of shape (m, n) containing the input field.</span>
<span class="sd">    fft_method: object</span>
<span class="sd">        A module or object implementing the same methods as numpy.fft and</span>
<span class="sd">        scipy.fftpack. If set to None, field is assumed to represent the</span>
<span class="sd">        shifted discrete Fourier transform of the input field, where the</span>
<span class="sd">        origin is at the center of the array</span>
<span class="sd">        (see numpy.fft.fftshift or scipy.fftpack.fftshift).</span>
<span class="sd">    return_freq: bool</span>
<span class="sd">        Whether to also return the Fourier frequencies.</span>
<span class="sd">    d: scalar</span>
<span class="sd">        Sample spacing (inverse of the sampling rate). Defaults to 1.</span>
<span class="sd">        Applicable if return_freq is &#39;True&#39;.</span>
<span class="sd">    normalize: bool</span>
<span class="sd">        If True, normalize the power spectrum so that it sums to one.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: ndarray</span>
<span class="sd">      One-dimensional array containing the RAPSD. The length of the array is</span>
<span class="sd">      int(l/2) (if l is even) or int(l/2)+1 (if l is odd), where l=max(m,n).</span>
<span class="sd">    freq: ndarray</span>
<span class="sd">      One-dimensional array containing the Fourier frequencies.</span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    :cite:`RC2011`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dimensions are found, but the number &quot;</span>
            <span class="s2">&quot;of dimensions should be 2&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input field should not contain nans&quot;</span><span class="p">)</span>


    <span class="n">y_coords</span><span class="p">,</span>  <span class="n">x_coords</span> <span class="o">=</span> <span class="n">compute_centred_coord_array</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">radial_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">x_coords</span> <span class="o">*</span>  <span class="n">x_coords</span> <span class="o">+</span> <span class="n">y_coords</span> <span class="o">*</span> <span class="n">y_coords</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
    <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 

    <span class="k">if</span> <span class="n">max_dim</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">radial_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radial_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">fft_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">fft_method</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft_method</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">fft_kwargs</span><span class="p">))</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">psd</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">data</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radial_range</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">radial_grid</span> <span class="o">==</span> <span class="n">r</span>
        <span class="n">psd_vals</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd_vals</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_freq</span><span class="p">:</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">radial_range</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">frequencies</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lexi Xu, Emily O&#39;Riordan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>